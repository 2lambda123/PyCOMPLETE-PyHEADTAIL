
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
    <title>PyHEADTAIL.monitors package &#8212; PyHEADTAIL  documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="PyHEADTAIL.multipoles package" href="PyHEADTAIL.multipoles.html" />
    <link rel="prev" title="PyHEADTAIL.machines package" href="PyHEADTAIL.machines.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="PyHEADTAIL.multipoles.html" title="PyHEADTAIL.multipoles package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="PyHEADTAIL.machines.html" title="PyHEADTAIL.machines package"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PyHEADTAIL  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="PyHEADTAIL.html" accesskey="U">PyHEADTAIL package</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-PyHEADTAIL.monitors">
<span id="pyheadtail-monitors-package"></span><h1>PyHEADTAIL.monitors package<a class="headerlink" href="#module-PyHEADTAIL.monitors" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-PyHEADTAIL.monitors.monitors">
<span id="pyheadtail-monitors-monitors-module"></span><h2>PyHEADTAIL.monitors.monitors module<a class="headerlink" href="#module-PyHEADTAIL.monitors.monitors" title="Permalink to this headline">¶</a></h2>
<p>&#64;author Kevin Li, Michael Schenk, Stefan Hegglin
&#64;date 11. February 2014
&#64;brief Implementation of monitors to store bunch-, slice- or particle-</p>
<blockquote>
<div><p>specific data to a HDF5 file.</p>
</div></blockquote>
<p>&#64;copyright CERN</p>
<dl class="class">
<dt id="PyHEADTAIL.monitors.monitors.BunchMonitor">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.monitors.monitors.</code><code class="sig-name descname">BunchMonitor</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">n_steps</em>, <em class="sig-param">parameters_dict=None</em>, <em class="sig-param">write_buffer_every=512</em>, <em class="sig-param">buffer_size=4096</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.BunchMonitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to store bunch-specific data to a HDF5 file. This monitor
uses a buffer (a shift register) to reduce the number of writing
operations to file. This also helps to avoid IO errors and loss of
data when writing to a file that may become temporarily unavailable
(e.g. if file is located on network) during the simulation.</p>
<dl class="attribute">
<dt id="PyHEADTAIL.monitors.monitors.BunchMonitor.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.BunchMonitor.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.monitors.monitors.BunchMonitor.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">n_steps</em>, <em class="sig-param">parameters_dict=None</em>, <em class="sig-param">write_buffer_every=512</em>, <em class="sig-param">buffer_size=4096</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.BunchMonitor.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an instance of a BunchMonitor class. Apart from
initializing the HDF5 file, a self.buffer dictionary is
prepared to buffer the data before writing them to file.</p>
<blockquote>
<div><dl class="simple">
<dt>filename:           Path and name of HDF5 file. Without file</dt><dd><p>extension.</p>
</dd>
<dt>n_steps:            Number of entries to be reserved for each</dt><dd><p>of the quantities in self.stats_to_store.</p>
</dd>
<dt>parameters_dict:    Metadata for HDF5 file containing main</dt><dd><p>simulation parameters.</p>
</dd>
<dt>write_buffer_every: Number of steps after which buffer</dt><dd><p>contents are actually written to file.</p>
</dd>
</dl>
<p>buffer_size:        Number of steps to be buffered.</p>
<p>Optionally pass a list called stats_to_store which specifies
which members/methods of the bunch will be called/stored.</p>
</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.monitors.monitors.BunchMonitor.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.monitors.monitors'</em><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.BunchMonitor.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.monitors.monitors.BunchMonitor._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.BunchMonitor._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.monitors.monitors.BunchMonitor._create_file_structure">
<code class="sig-name descname">_create_file_structure</code><span class="sig-paren">(</span><em class="sig-param">parameters_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.BunchMonitor._create_file_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize HDF5 file and create its basic structure (groups
and datasets). One group is created for bunch-specific data.
One dataset for each of the quantities defined in
self.stats_to_store is generated.
If specified by the user, write the contents of the
parameters_dict as metadata (attributes) to the file.
Maximum file compression is activated.</p>
</dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.monitors.monitors.BunchMonitor._init_buffer">
<code class="sig-name descname">_init_buffer</code><span class="sig-paren">(</span><em class="sig-param">bunch</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.BunchMonitor._init_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Init the correct buffer type (np.zeros, gpuarrays.zeros)</p>
</dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.monitors.monitors.BunchMonitor._write_buffer_to_file">
<code class="sig-name descname">_write_buffer_to_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.BunchMonitor._write_buffer_to_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Write buffer contents to the HDF5 file. The file is opened and
closed each time the buffer is written to file to prevent from
loss of data in case of a crash.
buffer_tmp is an extra buffer which is always on the CPU. If
self.buffer is on the GPU, copy the data to buffer_tmp and write
the result to the file.</p>
</dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.monitors.monitors.BunchMonitor._write_data_to_buffer">
<code class="sig-name descname">_write_data_to_buffer</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.BunchMonitor._write_data_to_buffer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.monitors.monitors.BunchMonitor.dump">
<code class="sig-name descname">dump</code><span class="sig-paren">(</span><em class="sig-param">bunch</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.BunchMonitor.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the statistics like mean and standard deviation for
the given bunch and write the data to the HDF5 file. Make use of
a buffer to reduce the number of writing operations to file.
This helps to avoid IO errors and loss of data when writing data
to a file that may become temporarily unavailable (e.g. if file
is on network). during the simulation. Buffer contents are
written to file only every self.write_buffer_every steps.
The buffer gets initialized in the first dump() call. This allows
for a dynamic creation of the buffer memory on either CPU or GPU</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.monitors.monitors.CellMonitor">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.monitors.monitors.</code><code class="sig-name descname">CellMonitor</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">n_steps</em>, <em class="sig-param">n_azimuthal_slices</em>, <em class="sig-param">n_radial_slices</em>, <em class="sig-param">radial_cut</em>, <em class="sig-param">beta_z</em>, <em class="sig-param">parameters_dict=None</em>, <em class="sig-param">write_buffer_every=512</em>, <em class="sig-param">buffer_size=4096</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.CellMonitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to store cell (z, dp) specific data (for the moment only
mean_x, mean_y, mean_z, mean_dp and n_particles_in_cell) to a HDF5
file. This monitor uses a buffer (shift register) to reduce the
number of writing operations to file. This also helps to avoid IO
errors and loss of data when writing to a file that may become
temporarily unavailable (e.g. if file is located on network) during
the simulation.</p>
<dl class="attribute">
<dt id="PyHEADTAIL.monitors.monitors.CellMonitor.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.CellMonitor.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.monitors.monitors.CellMonitor.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">n_steps</em>, <em class="sig-param">n_azimuthal_slices</em>, <em class="sig-param">n_radial_slices</em>, <em class="sig-param">radial_cut</em>, <em class="sig-param">beta_z</em>, <em class="sig-param">parameters_dict=None</em>, <em class="sig-param">write_buffer_every=512</em>, <em class="sig-param">buffer_size=4096</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.CellMonitor.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an instance of a CellMonitor class. Apart from
initializing the HDF5 file, a buffer self.buffer_cell is
prepared to buffer the cell-specific data before writing them
to file.</p>
<blockquote>
<div><dl class="simple">
<dt>filename:           Path and name of HDF5 file. Without file</dt><dd><p>extension.</p>
</dd>
<dt>n_steps:            Number of entries to be reserved for each</dt><dd><p>of the quantities in self.stats_to_store.</p>
</dd>
</dl>
<p>n_azimuthal_slices: Number of pizza slices (azimuthal slicing).
n_radial_slices:    Number of rings (radial slicing).
radial_cut:         ‘Radius’ of the outermost ring in</p>
<blockquote>
<div><p>longitudinal phase space (using beta_z*dp)</p>
</div></blockquote>
<dl class="simple">
<dt>parameters_dict:    Metadata for HDF5 file containing main</dt><dd><p>simulation parameters.</p>
</dd>
<dt>write_buffer_every: Number of steps after which buffer</dt><dd><p>contents are actually written to file.</p>
</dd>
</dl>
<p>buffer_size:        Number of steps to be buffered.</p>
</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.monitors.monitors.CellMonitor.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.monitors.monitors'</em><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.CellMonitor.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.monitors.monitors.CellMonitor._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.CellMonitor._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.monitors.monitors.CellMonitor._create_file_structure">
<code class="sig-name descname">_create_file_structure</code><span class="sig-paren">(</span><em class="sig-param">parameters_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.CellMonitor._create_file_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize HDF5 file and create its basic structure (groups
and datasets). One dataset for each of the quantities defined
in self.stats_to_store is generated. If specified by
the user, write the contents of the parameters_dict as metadata
(attributes) to the file. Maximum file compression is
activated.</p>
</dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.monitors.monitors.CellMonitor._write_buffer_to_file">
<code class="sig-name descname">_write_buffer_to_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.CellMonitor._write_buffer_to_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Write buffer contents to the HDF5 file. The file is opened
and closed each time the buffer is written to file to prevent
from loss of data in case of a crash.</p>
</dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.monitors.monitors.CellMonitor._write_data_to_buffer">
<code class="sig-name descname">_write_data_to_buffer</code><span class="sig-paren">(</span><em class="sig-param">bunch</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.CellMonitor._write_data_to_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Store the data in the self.buffer dictionary before writing
them to file. The buffer is implemented as a shift register. The
cell-specific data are computed by a cython function.</p>
</dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.monitors.monitors.CellMonitor.dump">
<code class="sig-name descname">dump</code><span class="sig-paren">(</span><em class="sig-param">bunch</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.CellMonitor.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the statistics for the given cells and write the
data to the buffer and/or to the HDF5 file. The buffer is used
to reduce the number of writing operations to file. This helps
to avoid IO errors and loss of data when writing data to a file
that may become temporarily unavailable (e.g. if file is on
network) during the simulation. Buffer contents are written to
file only every self.write_buffer_every steps.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.monitors.monitors.Monitor">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.monitors.monitors.</code><code class="sig-name descname">Monitor</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.Monitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for monitors. A monitor can request
statistics data such as mean value and standard deviation and store
the results in an HDF5 file.</p>
<dl class="attribute">
<dt id="PyHEADTAIL.monitors.monitors.Monitor.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({'dump'})</em><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.Monitor.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.monitors.monitors.Monitor.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.monitors.monitors'</em><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.Monitor.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.monitors.monitors.Monitor._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.Monitor._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.monitors.monitors.Monitor.dump">
<em class="property">abstract </em><code class="sig-name descname">dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.Monitor.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Write particle data given by bunch (instance of Particles
class) to buffer and/or file at the specific time the method is
called. Data can e.g. be bunch-specific, slice_set-specific or
particle-specific.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.monitors.monitors.ParticleMonitor">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.monitors.monitors.</code><code class="sig-name descname">ParticleMonitor</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">stride=1</em>, <em class="sig-param">parameters_dict=None</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.ParticleMonitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to store particle-specific data to a HDF5 file, i.e. the
coordinates and conjugate momenta as well as the id of individual
macroparticles of a bunch.</p>
<dl class="attribute">
<dt id="PyHEADTAIL.monitors.monitors.ParticleMonitor.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.ParticleMonitor.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.monitors.monitors.ParticleMonitor.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">stride=1</em>, <em class="sig-param">parameters_dict=None</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.ParticleMonitor.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an instance of a ParticleMonitor class. The HDF5 file
is initialized, and if specified, the parameters_dict is written
to file.</p>
<blockquote>
<div><dl class="simple">
<dt>filename:        Path and name of HDF5 file. Without file</dt><dd><p>extension.</p>
</dd>
<dt>stride:          Only store data of macroparticles for which</dt><dd><p>id % stride == 0.</p>
</dd>
<dt>parameters_dict: Metadata for HDF5 file containing main</dt><dd><p>simulation parameters.</p>
</dd>
</dl>
<p>Optionally pass a list called quantities_to_store which
specifies which members of the bunch will be called/stored.</p>
</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.monitors.monitors.ParticleMonitor.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.monitors.monitors'</em><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.ParticleMonitor.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.monitors.monitors.ParticleMonitor._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.ParticleMonitor._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.monitors.monitors.ParticleMonitor._create_file_structure">
<code class="sig-name descname">_create_file_structure</code><span class="sig-paren">(</span><em class="sig-param">parameters_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.ParticleMonitor._create_file_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize HDF5 file. If specified by the user, write the
contents of the parameters_dict as metadata (attributes)
to the file. Maximum file compression is activated.</p>
</dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.monitors.monitors.ParticleMonitor._write_data_to_file">
<code class="sig-name descname">_write_data_to_file</code><span class="sig-paren">(</span><em class="sig-param">bunch</em>, <em class="sig-param">arrays_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.ParticleMonitor._write_data_to_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Write macroparticle data (x, xp, y, yp, z, dp, id) of a
selection of particles to the HDF5 file. Optionally, data in
additional_quantities can also be added if provided in the
constructor. The file is opened and closed every time to prevent
from loss of data in case of a crash.
For each simulation step, a new group with name ‘Step#..’ is
created. It contains one dataset for each of the quantities
given in self.quantities_to_store.</p>
</dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.monitors.monitors.ParticleMonitor.dump">
<code class="sig-name descname">dump</code><span class="sig-paren">(</span><em class="sig-param">bunch</em>, <em class="sig-param">arrays_dict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.ParticleMonitor.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Write particle data to file. See docstring of method
self._write_data_to_file .</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.monitors.monitors.SliceMonitor">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.monitors.monitors.</code><code class="sig-name descname">SliceMonitor</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">n_steps</em>, <em class="sig-param">slicer</em>, <em class="sig-param">parameters_dict=None</em>, <em class="sig-param">write_buffer_every=512</em>, <em class="sig-param">buffer_size=4096</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.SliceMonitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to store bunch- and slice_set-specific data to a HDF5
file. This monitor uses two buffers (shift registers) to reduce the
number of writing operations to file. This also helps to avoid IO
errors and loss of data when writing to a file that may become
temporarily unavailable (e.g. if file is located on network) during
the simulation.</p>
<dl class="attribute">
<dt id="PyHEADTAIL.monitors.monitors.SliceMonitor.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.SliceMonitor.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.monitors.monitors.SliceMonitor.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">n_steps</em>, <em class="sig-param">slicer</em>, <em class="sig-param">parameters_dict=None</em>, <em class="sig-param">write_buffer_every=512</em>, <em class="sig-param">buffer_size=4096</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.SliceMonitor.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an instance of a SliceMonitor class. Apart from
initializing the HDF5 file, two buffers self.buffer_bunch and
self.buffer_slice are prepared to buffer the bunch-specific and
slice_set-specific data before writing them to file.</p>
<blockquote>
<div><dl class="simple">
<dt>filename:           Path and name of HDF5 file. Without file</dt><dd><p>extension.</p>
</dd>
<dt>n_steps:            Number of entries to be reserved for each</dt><dd><p>of the quantities in self.stats_to_store.</p>
</dd>
<dt>slicer:             Instance of the Slicer class containing</dt><dd><p>the configuration defining a slice_set.</p>
</dd>
<dt>parameters_dict:    Metadata for HDF5 file containing main</dt><dd><p>simulation parameters.</p>
</dd>
<dt>write_buffer_every: Number of steps after which buffer</dt><dd><p>contents are actually written to file.</p>
</dd>
</dl>
<p>buffer_size:        Number of steps to be buffered.</p>
<p>optionally pass a list called bunch_stats_to_store or
slice_stats_to_store which specifie
which members/methods of the bunch will be called/stored.</p>
</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.monitors.monitors.SliceMonitor.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.monitors.monitors'</em><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.SliceMonitor.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.monitors.monitors.SliceMonitor._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.SliceMonitor._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.monitors.monitors.SliceMonitor._create_file_structure">
<code class="sig-name descname">_create_file_structure</code><span class="sig-paren">(</span><em class="sig-param">parameters_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.SliceMonitor._create_file_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize HDF5 file and create its basic structure (groups
and datasets). Two groups are created, one for slice_set-
specific and one for bunch-specific data. One dataset for each
of the quantities defined in self.bunch_stats_to_store and
self.slice_stats_to_store resp. is generated. If specified by
the user, write the contents of the parameters_dict as metadata
(attributes) to the file. Maximum file compression is
activated.</p>
</dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.monitors.monitors.SliceMonitor._init_buffer">
<code class="sig-name descname">_init_buffer</code><span class="sig-paren">(</span><em class="sig-param">bunch</em>, <em class="sig-param">slice_set</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.SliceMonitor._init_buffer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.monitors.monitors.SliceMonitor._write_buffer_to_file">
<code class="sig-name descname">_write_buffer_to_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.SliceMonitor._write_buffer_to_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Write buffer contents to the HDF5 file. The file is opened
and closed each time the buffer is written to file to prevent
from loss of data in case of a crash.</p>
</dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.monitors.monitors.SliceMonitor._write_data_to_buffer">
<code class="sig-name descname">_write_data_to_buffer</code><span class="sig-paren">(</span><em class="sig-param">bunch</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.SliceMonitor._write_data_to_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Store the data in the self.buffer dictionary before writing
them to file. The buffer is implemented as a shift register. To
find the slice_set-specific data, a slice_set, defined by the
slicing configuration self.slicer must be requested from the
bunch (instance of the Particles class), including all the
statistics that are to be saved.</p>
</dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.monitors.monitors.SliceMonitor.dump">
<code class="sig-name descname">dump</code><span class="sig-paren">(</span><em class="sig-param">bunch</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.monitors.monitors.SliceMonitor.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the statistics like mean and standard deviation for
the given slice_set and the bunch and write the data to the
buffers and/or to the HDF5 file. The buffers are used to reduce
the number of writing operations to file. This helps to avoid IO
errors and loss of data when writing data to a file that may
become temporarily unavailable (e.g. if file is on network)
during the simulation. Buffer contents are written to file only
every self.write_buffer_every steps.</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">PyHEADTAIL.monitors package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-PyHEADTAIL.monitors.monitors">PyHEADTAIL.monitors.monitors module</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="PyHEADTAIL.machines.html"
                        title="previous chapter">PyHEADTAIL.machines package</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="PyHEADTAIL.multipoles.html"
                        title="next chapter">PyHEADTAIL.multipoles package</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/PyHEADTAIL.monitors.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="PyHEADTAIL.multipoles.html" title="PyHEADTAIL.multipoles package"
             >next</a> |</li>
        <li class="right" >
          <a href="PyHEADTAIL.machines.html" title="PyHEADTAIL.machines package"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PyHEADTAIL  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="PyHEADTAIL.html" >PyHEADTAIL package</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Author.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.3.1.
    </div>
  </body>
</html>