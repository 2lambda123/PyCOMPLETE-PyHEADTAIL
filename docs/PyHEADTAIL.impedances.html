
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
    <title>PyHEADTAIL.impedances package &#8212; PyHEADTAIL  documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="PyHEADTAIL.machines package" href="PyHEADTAIL.machines.html" />
    <link rel="prev" title="PyHEADTAIL.gpu package" href="PyHEADTAIL.gpu.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="PyHEADTAIL.machines.html" title="PyHEADTAIL.machines package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="PyHEADTAIL.gpu.html" title="PyHEADTAIL.gpu package"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PyHEADTAIL  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="PyHEADTAIL.html" accesskey="U">PyHEADTAIL package</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-PyHEADTAIL.impedances">
<span id="pyheadtail-impedances-package"></span><h1>PyHEADTAIL.impedances package<a class="headerlink" href="#module-PyHEADTAIL.impedances" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-PyHEADTAIL.impedances.wake_kicks">
<span id="pyheadtail-impedances-wake-kicks-module"></span><h2>PyHEADTAIL.impedances.wake_kicks module<a class="headerlink" href="#module-PyHEADTAIL.impedances.wake_kicks" title="Permalink to this headline">¶</a></h2>
<p>&#64;class WakeKick
&#64;author Kevin Li, Michael Schenk
&#64;date July 2014
&#64;brief Implementation of the wake kicks, i.e. of the elementary objects</p>
<blockquote>
<div><p>describing the effects of a wake field.</p>
</div></blockquote>
<p>&#64;copyright CERN</p>
<dl class="class">
<dt id="PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickX">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wake_kicks.</code><code class="sig-name descname">ConstantWakeKickX</code><span class="sig-paren">(</span><em class="sig-param">wake_function</em>, <em class="sig-param">slicer</em>, <em class="sig-param">n_turns_wake</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickX" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickX.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickX.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickX.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wake_kicks'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickX.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickX._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickX._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickX.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">bunch</em>, <em class="sig-param">slice_set_list</em>, <em class="sig-param">slice_set_age_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickX.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate and apply a constant wake kick to bunch.xp
using the given slice_set. Only particles within the slicing
region, i.e particles_within_cuts (defined by the slice_set)
experience the kick.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickY">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wake_kicks.</code><code class="sig-name descname">ConstantWakeKickY</code><span class="sig-paren">(</span><em class="sig-param">wake_function</em>, <em class="sig-param">slicer</em>, <em class="sig-param">n_turns_wake</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickY" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickY.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickY.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickY.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wake_kicks'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickY.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickY._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickY._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickY.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">bunch</em>, <em class="sig-param">slice_set_list</em>, <em class="sig-param">slice_set_age_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickY.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate and apply a constant wake kick to bunch.yp
using the given slice_set. Only particles within the slicing
region, i.e particles_within_cuts (defined by the slice_set)
experience the kick.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickZ">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wake_kicks.</code><code class="sig-name descname">ConstantWakeKickZ</code><span class="sig-paren">(</span><em class="sig-param">wake_function</em>, <em class="sig-param">slicer</em>, <em class="sig-param">n_turns_wake</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickZ" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickZ.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickZ.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickZ.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wake_kicks'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickZ.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickZ._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickZ._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickZ.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">bunch</em>, <em class="sig-param">slice_set_list</em>, <em class="sig-param">slice_set_age_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.ConstantWakeKickZ.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate and apply a constant wake kick to bunch.dp
using the given slice_set. Only particles within the slicing
region, i.e particles_within_cuts (defined by the slice_set)
experience the kick.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickX">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wake_kicks.</code><code class="sig-name descname">DipoleWakeKickX</code><span class="sig-paren">(</span><em class="sig-param">wake_function</em>, <em class="sig-param">slicer</em>, <em class="sig-param">n_turns_wake</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickX" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickX.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickX.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickX.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wake_kicks'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickX.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickX._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickX._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickX.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">bunch</em>, <em class="sig-param">slice_set_list</em>, <em class="sig-param">slice_set_age_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickX.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate and apply a dipolar wake kick to bunch.xp
using the given slice_set. Only particles within the slicing
region, i.e particles_within_cuts (defined by the slice_set)
experience the kick.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickXY">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wake_kicks.</code><code class="sig-name descname">DipoleWakeKickXY</code><span class="sig-paren">(</span><em class="sig-param">wake_function</em>, <em class="sig-param">slicer</em>, <em class="sig-param">n_turns_wake</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickXY" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickXY.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickXY.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickXY.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wake_kicks'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickXY.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickXY._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickXY._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickXY.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">bunch</em>, <em class="sig-param">slice_set_list</em>, <em class="sig-param">slice_set_age_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickXY.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate and apply a dipolar (cross term x-y) wake kick
to bunch.xp using the given slice_set. Only particles within
the slicing region, i.e particles_within_cuts (defined by the
slice_set) experience the kick.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickY">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wake_kicks.</code><code class="sig-name descname">DipoleWakeKickY</code><span class="sig-paren">(</span><em class="sig-param">wake_function</em>, <em class="sig-param">slicer</em>, <em class="sig-param">n_turns_wake</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickY" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickY.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickY.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickY.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wake_kicks'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickY.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickY._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickY._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickY.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">bunch</em>, <em class="sig-param">slice_set_list</em>, <em class="sig-param">slice_set_age_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickY.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate and apply a dipolar wake kick to bunch.yp
using the given slice_set. Only particles within the slicing
region, i.e particles_within_cuts (defined by the slice_set)
experience the kick.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickYX">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wake_kicks.</code><code class="sig-name descname">DipoleWakeKickYX</code><span class="sig-paren">(</span><em class="sig-param">wake_function</em>, <em class="sig-param">slicer</em>, <em class="sig-param">n_turns_wake</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickYX" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickYX.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickYX.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickYX.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wake_kicks'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickYX.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickYX._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickYX._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickYX.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">bunch</em>, <em class="sig-param">slice_set_list</em>, <em class="sig-param">slice_set_age_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.DipoleWakeKickYX.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate and apply a dipolar (cross term y-x) wake kick
to bunch.yp using the given slice_set. Only particles within
the slicing region, i.e particles_within_cuts (defined by the
slice_set) experience the kick.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickX">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wake_kicks.</code><code class="sig-name descname">QuadrupoleWakeKickX</code><span class="sig-paren">(</span><em class="sig-param">wake_function</em>, <em class="sig-param">slicer</em>, <em class="sig-param">n_turns_wake</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickX" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickX.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickX.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickX.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wake_kicks'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickX.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickX._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickX._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickX.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">bunch</em>, <em class="sig-param">slice_set_list</em>, <em class="sig-param">slice_set_age_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickX.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate and apply a quadrupolar wake kick to bunch.xp
using the given slice_set. Only particles within the slicing
region, i.e particles_within_cuts (defined by the slice_set)
experience the kick.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickXY">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wake_kicks.</code><code class="sig-name descname">QuadrupoleWakeKickXY</code><span class="sig-paren">(</span><em class="sig-param">wake_function</em>, <em class="sig-param">slicer</em>, <em class="sig-param">n_turns_wake</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickXY" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickXY.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickXY.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickXY.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wake_kicks'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickXY.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickXY._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickXY._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickXY.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">bunch</em>, <em class="sig-param">slice_set_list</em>, <em class="sig-param">slice_set_age_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickXY.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate and apply a quadrupolar (cross term x-y) wake
kick to bunch.xp using the given slice_set. Only particles
within the slicing region, i.e particles_within_cuts (defined by
the slice_set) experience the kick.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickY">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wake_kicks.</code><code class="sig-name descname">QuadrupoleWakeKickY</code><span class="sig-paren">(</span><em class="sig-param">wake_function</em>, <em class="sig-param">slicer</em>, <em class="sig-param">n_turns_wake</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickY" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickY.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickY.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickY.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wake_kicks'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickY.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickY._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickY._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickY.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">bunch</em>, <em class="sig-param">slice_set_list</em>, <em class="sig-param">slice_set_age_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickY.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate and apply a quadrupolar wake kick to bunch.yp
using the given slice_set. Only particles within the slicing
region, i.e particles_within_cuts (defined by the slice_set)
experience the kick.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickYX">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wake_kicks.</code><code class="sig-name descname">QuadrupoleWakeKickYX</code><span class="sig-paren">(</span><em class="sig-param">wake_function</em>, <em class="sig-param">slicer</em>, <em class="sig-param">n_turns_wake</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickYX" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickYX.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickYX.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickYX.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wake_kicks'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickYX.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickYX._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickYX._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickYX.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">bunch</em>, <em class="sig-param">slice_set_list</em>, <em class="sig-param">slice_set_age_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.QuadrupoleWakeKickYX.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate and apply a quadrupolar (cross term y-x) wake
kick to bunch.yp using the given slice_set. Only particles
within the slicing region, i.e particles_within_cuts (defined by
the slice_set) experience the kick.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.impedances.wake_kicks.WakeKick">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wake_kicks.</code><code class="sig-name descname">WakeKick</code><span class="sig-paren">(</span><em class="sig-param">wake_function</em>, <em class="sig-param">slicer</em>, <em class="sig-param">n_turns_wake</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.WakeKick" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for wake kick classes, like e.g. the
DipoleWakeKickX.
Provides the basic and universal methods to calculate the strength
of a wake kick. Two implementations of the convolution are
available. Based on what slicer mode (uniform_bin, uniform_charge)
is used, the self._convolution method is bound to one or the other.
The self.apply(bunch, slice_set) method calculates and applies the
corresponding kick to the particles of the bunch that are located
inside the slicing region defined by a slice_set. This should be
the only method to be implemented for a child class inheriting from
the WakeKick class.</p>
<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.WakeKick.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({'apply'})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.WakeKick.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wake_kicks.WakeKick.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">wake_function</em>, <em class="sig-param">slicer</em>, <em class="sig-param">n_turns_wake</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.WakeKick.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Universal constructor for WakeKick objects. The slicer_mode
is passed only to decide about which of the two implementations
of the convolution the self._convolution method is bound to.</p>
</dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.WakeKick.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wake_kicks'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.WakeKick.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wake_kicks.WakeKick._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.WakeKick._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wake_kicks.WakeKick._accumulate_source_signal">
<code class="sig-name descname">_accumulate_source_signal</code><span class="sig-paren">(</span><em class="sig-param">bunch</em>, <em class="sig-param">times_list</em>, <em class="sig-param">ages_list</em>, <em class="sig-param">moments_list</em>, <em class="sig-param">betas_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.WakeKick._accumulate_source_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Accumulate (multiturn-)wake signals left by source slices.
Takes a list of slice set attributes and adds up all
convolutions weighted by the respective moments. Also updates
the age of each slice set.</p>
</dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wake_kicks.WakeKick._convolution_dot_product">
<code class="sig-name descname">_convolution_dot_product</code><span class="sig-paren">(</span><em class="sig-param">target_times</em>, <em class="sig-param">source_times</em>, <em class="sig-param">source_moments</em>, <em class="sig-param">source_beta</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.WakeKick._convolution_dot_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Implementation of the convolution of wake and source_moments
(beam profile) using the numpy dot product. To be used with the
‘uniform_charge’ slicer mode.</p>
</dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wake_kicks.WakeKick._convolution_numpy">
<code class="sig-name descname">_convolution_numpy</code><span class="sig-paren">(</span><em class="sig-param">target_times</em>, <em class="sig-param">source_times</em>, <em class="sig-param">source_moments</em>, <em class="sig-param">source_beta</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.WakeKick._convolution_numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Implementation of the convolution of wake and source_moments
(longitudinal beam profile) using the numpy built-in
numpy.convolve method. Recommended use with the ‘uniform_bin’
slicer mode (in case of multiturn wakes, additional conditions
must be fulfilled: fixed z_cuts and no acceleration!) for
higher performance. Question: how about interpolation to avoid
expensive dot product in most cases?</p>
</dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wake_kicks.WakeKick._wake_factor">
<em class="property">static </em><code class="sig-name descname">_wake_factor</code><span class="sig-paren">(</span><em class="sig-param">bunch</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.WakeKick._wake_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Universal scaling factor for the strength of a wake field
kick.</p>
</dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wake_kicks.WakeKick.apply">
<em class="property">abstract </em><code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">bunch</em>, <em class="sig-param">slice_set_list</em>, <em class="sig-param">slice_set_age_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wake_kicks.WakeKick.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate and apply the corresponding wake kick to the
bunch conjugate momenta using the given slice_set. Only
particles within the slicing region, i.e particles_within_cuts
(defined by the slice_set) experience a kick.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-PyHEADTAIL.impedances.wakes">
<span id="pyheadtail-impedances-wakes-module"></span><h2>PyHEADTAIL.impedances.wakes module<a class="headerlink" href="#module-PyHEADTAIL.impedances.wakes" title="Permalink to this headline">¶</a></h2>
<p>This module includes the description of a (multiturn) WakeField as well
as the implementation of the WakeSource objects.</p>
<p>A WakeField is defined as a composition of the elementary WakeKick
objects (see .wake_kicks module). They originate from WakeSources,
e.g. a WakeTable, Resonator and/or a ResistiveWall. The WakeField does
not directly accept the WakeKick objects, but takes a list of
WakeSources first (can be of different kinds), each of which knows how
to generate its WakeKick objects via the factory method
WakeSource.get_wake_kicks(..). The collection of WakeKicks from all the
WakeSources define the WakeField and are the elementary objects that are
stored, (i.e. the WakeField forgets about the origin of the WakeKicks
once they have been created).</p>
<p>&#64;author Hannes Bartosik, Kevin Li, Giovanni Rumolo, Michael Schenk
&#64;date March 2014
&#64;brief Implementation of a WakeField as a composition of WakeKicks</p>
<blockquote>
<div><p>originating from different WakeSources.</p>
</div></blockquote>
<p>&#64;copyright CERN</p>
<dl class="class">
<dt id="PyHEADTAIL.impedances.wakes.CircularResistiveWall">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wakes.</code><code class="sig-name descname">CircularResistiveWall</code><span class="sig-paren">(</span><em class="sig-param">pipe_radius</em>, <em class="sig-param">resistive_wall_length</em>, <em class="sig-param">conductivity</em>, <em class="sig-param">dt_min</em>, <em class="sig-param">n_turns_wake=1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.CircularResistiveWall" title="Permalink to this definition">¶</a></dt>
<dd><p>Circular resistive wall.</p>
<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.CircularResistiveWall.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.CircularResistiveWall.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wakes.CircularResistiveWall.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">pipe_radius</em>, <em class="sig-param">resistive_wall_length</em>, <em class="sig-param">conductivity</em>, <em class="sig-param">dt_min</em>, <em class="sig-param">n_turns_wake=1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.CircularResistiveWall.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Special case of a circular resistive wall.</p>
</dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.CircularResistiveWall.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wakes'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.CircularResistiveWall.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.CircularResistiveWall._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.CircularResistiveWall._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.impedances.wakes.CircularResonator">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wakes.</code><code class="sig-name descname">CircularResonator</code><span class="sig-paren">(</span><em class="sig-param">R_shunt</em>, <em class="sig-param">frequency</em>, <em class="sig-param">Q</em>, <em class="sig-param">n_turns_wake=1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.CircularResonator" title="Permalink to this definition">¶</a></dt>
<dd><p>Circular Resonator.</p>
<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.CircularResonator.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.CircularResonator.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wakes.CircularResonator.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">R_shunt</em>, <em class="sig-param">frequency</em>, <em class="sig-param">Q</em>, <em class="sig-param">n_turns_wake=1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.CircularResonator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Special case of circular resonator.</p>
</dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.CircularResonator.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wakes'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.CircularResonator.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.CircularResonator._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.CircularResonator._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.impedances.wakes.ParallelHorizontalPlatesResistiveWall">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wakes.</code><code class="sig-name descname">ParallelHorizontalPlatesResistiveWall</code><span class="sig-paren">(</span><em class="sig-param">pipe_radius</em>, <em class="sig-param">resistive_wall_length</em>, <em class="sig-param">conductivity</em>, <em class="sig-param">dt_min</em>, <em class="sig-param">n_turns_wake=1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ParallelHorizontalPlatesResistiveWall" title="Permalink to this definition">¶</a></dt>
<dd><p>Resistive wall impedance for horizontal parallel plates.</p>
<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.ParallelHorizontalPlatesResistiveWall.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ParallelHorizontalPlatesResistiveWall.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wakes.ParallelHorizontalPlatesResistiveWall.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">pipe_radius</em>, <em class="sig-param">resistive_wall_length</em>, <em class="sig-param">conductivity</em>, <em class="sig-param">dt_min</em>, <em class="sig-param">n_turns_wake=1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ParallelHorizontalPlatesResistiveWall.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Special case of a parallel plates resistive wall.</p>
</dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.ParallelHorizontalPlatesResistiveWall.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wakes'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ParallelHorizontalPlatesResistiveWall.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.ParallelHorizontalPlatesResistiveWall._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ParallelHorizontalPlatesResistiveWall._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.impedances.wakes.ParallelHorizontalPlatesResonator">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wakes.</code><code class="sig-name descname">ParallelHorizontalPlatesResonator</code><span class="sig-paren">(</span><em class="sig-param">R_shunt</em>, <em class="sig-param">frequency</em>, <em class="sig-param">Q</em>, <em class="sig-param">n_turns_wake=1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ParallelHorizontalPlatesResonator" title="Permalink to this definition">¶</a></dt>
<dd><p>Broad-band resonator for horizontal parallel plates.</p>
<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.ParallelHorizontalPlatesResonator.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ParallelHorizontalPlatesResonator.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wakes.ParallelHorizontalPlatesResonator.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">R_shunt</em>, <em class="sig-param">frequency</em>, <em class="sig-param">Q</em>, <em class="sig-param">n_turns_wake=1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ParallelHorizontalPlatesResonator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Special case of parallel plate resonator.</p>
</dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.ParallelHorizontalPlatesResonator.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wakes'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ParallelHorizontalPlatesResonator.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.ParallelHorizontalPlatesResonator._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ParallelHorizontalPlatesResonator._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="PyHEADTAIL.impedances.wakes.ParallelPlatesResistiveWall">
<code class="sig-prename descclassname">PyHEADTAIL.impedances.wakes.</code><code class="sig-name descname">ParallelPlatesResistiveWall</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ParallelPlatesResistiveWall" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="PyHEADTAIL.impedances.wakes.ParallelPlatesResonator">
<code class="sig-prename descclassname">PyHEADTAIL.impedances.wakes.</code><code class="sig-name descname">ParallelPlatesResonator</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ParallelPlatesResonator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.impedances.wakes.ParallelVerticalPlatesResistiveWall">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wakes.</code><code class="sig-name descname">ParallelVerticalPlatesResistiveWall</code><span class="sig-paren">(</span><em class="sig-param">pipe_radius</em>, <em class="sig-param">resistive_wall_length</em>, <em class="sig-param">conductivity</em>, <em class="sig-param">dt_min</em>, <em class="sig-param">n_turns_wake=1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ParallelVerticalPlatesResistiveWall" title="Permalink to this definition">¶</a></dt>
<dd><p>Resistive wall impedance for vertical parallel plates.</p>
<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.ParallelVerticalPlatesResistiveWall.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ParallelVerticalPlatesResistiveWall.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wakes.ParallelVerticalPlatesResistiveWall.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">pipe_radius</em>, <em class="sig-param">resistive_wall_length</em>, <em class="sig-param">conductivity</em>, <em class="sig-param">dt_min</em>, <em class="sig-param">n_turns_wake=1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ParallelVerticalPlatesResistiveWall.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Special case of a parallel plates resistive wall.</p>
</dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.ParallelVerticalPlatesResistiveWall.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wakes'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ParallelVerticalPlatesResistiveWall.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.ParallelVerticalPlatesResistiveWall._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ParallelVerticalPlatesResistiveWall._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.impedances.wakes.ParallelVerticalPlatesResonator">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wakes.</code><code class="sig-name descname">ParallelVerticalPlatesResonator</code><span class="sig-paren">(</span><em class="sig-param">R_shunt</em>, <em class="sig-param">frequency</em>, <em class="sig-param">Q</em>, <em class="sig-param">n_turns_wake=1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ParallelVerticalPlatesResonator" title="Permalink to this definition">¶</a></dt>
<dd><p>Broad-band resonator for vertical parallel plates.</p>
<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.ParallelVerticalPlatesResonator.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ParallelVerticalPlatesResonator.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wakes.ParallelVerticalPlatesResonator.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">R_shunt</em>, <em class="sig-param">frequency</em>, <em class="sig-param">Q</em>, <em class="sig-param">n_turns_wake=1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ParallelVerticalPlatesResonator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Special case of parallel plate resonator.</p>
</dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.ParallelVerticalPlatesResonator.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wakes'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ParallelVerticalPlatesResonator.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.ParallelVerticalPlatesResonator._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ParallelVerticalPlatesResonator._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.impedances.wakes.ResistiveWall">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wakes.</code><code class="sig-name descname">ResistiveWall</code><span class="sig-paren">(</span><em class="sig-param">pipe_radius</em>, <em class="sig-param">resistive_wall_length</em>, <em class="sig-param">conductivity</em>, <em class="sig-param">dt_min</em>, <em class="sig-param">Yokoya_X1</em>, <em class="sig-param">Yokoya_Y1</em>, <em class="sig-param">Yokoya_X2</em>, <em class="sig-param">Yokoya_Y2</em>, <em class="sig-param">n_turns_wake=1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ResistiveWall" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to describe the wake functions originating from a
resistive wall impedance.</p>
<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.ResistiveWall.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ResistiveWall.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wakes.ResistiveWall.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">pipe_radius</em>, <em class="sig-param">resistive_wall_length</em>, <em class="sig-param">conductivity</em>, <em class="sig-param">dt_min</em>, <em class="sig-param">Yokoya_X1</em>, <em class="sig-param">Yokoya_Y1</em>, <em class="sig-param">Yokoya_X2</em>, <em class="sig-param">Yokoya_Y2</em>, <em class="sig-param">n_turns_wake=1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ResistiveWall.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>General constructor to create a ResistiveWall WakeSource
object describing the wake functions of a resistive wall
impedance.
The parameter ‘n_turns_wake’ defines how many turns are
considered for the multiturn wakes. It is 1 by default, i.e.
multiturn wakes are off.</p>
</dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.ResistiveWall.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wakes'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ResistiveWall.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.ResistiveWall._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ResistiveWall._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wakes.ResistiveWall.function_transverse">
<code class="sig-name descname">function_transverse</code><span class="sig-paren">(</span><em class="sig-param">Yokoya_factor</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ResistiveWall.function_transverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the wake function (transverse) of a resistive wall
with the given parameters.</p>
</dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wakes.ResistiveWall.get_wake_kicks">
<code class="sig-name descname">get_wake_kicks</code><span class="sig-paren">(</span><em class="sig-param">slicer</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.ResistiveWall.get_wake_kicks" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory method. Creates instances of the appropriate
WakeKick objects for the ResistiveWall WakeSource with the
specified parameters. A WakeKick object is instantiated only if
the corresponding Yokoya factor is non-zero. The WakeKick
objects are returned as a list wake_kicks.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.impedances.wakes.Resonator">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wakes.</code><code class="sig-name descname">Resonator</code><span class="sig-paren">(</span><em class="sig-param">R_shunt</em>, <em class="sig-param">frequency</em>, <em class="sig-param">Q</em>, <em class="sig-param">Yokoya_X1</em>, <em class="sig-param">Yokoya_Y1</em>, <em class="sig-param">Yokoya_X2</em>, <em class="sig-param">Yokoya_Y2</em>, <em class="sig-param">switch_Z</em>, <em class="sig-param">n_turns_wake=1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.Resonator" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to describe the wake functions originating from a
resonator impedance. Alex Chao’s resonator model (Eq. 2.82) is used
as well as the definitions from HEADTAIL.</p>
<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.Resonator.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.Resonator.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wakes.Resonator.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">R_shunt</em>, <em class="sig-param">frequency</em>, <em class="sig-param">Q</em>, <em class="sig-param">Yokoya_X1</em>, <em class="sig-param">Yokoya_Y1</em>, <em class="sig-param">Yokoya_X2</em>, <em class="sig-param">Yokoya_Y2</em>, <em class="sig-param">switch_Z</em>, <em class="sig-param">n_turns_wake=1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.Resonator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>General constructor to create a Resonator WakeSource object
describing the wake functions of a resonator impedance. Alex
Chao’s resonator model (Eq. 2.82) is used as well as definitions
from HEADTAIL.
Note that it is no longer allowed to pass a LIST of parameters
to generate a number of resonators with different parameters
within the same Resonator object. Instead, create the Resonator
objects and pass all of them to the WakeField constructor.
The parameter ‘n_turns_wake’ defines how many turns are
considered for the multiturn wakes. It is 1 by default, i.e.
multiturn wakes are off.</p>
</dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.Resonator.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wakes'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.Resonator.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.Resonator._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.Resonator._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wakes.Resonator.function_longitudinal">
<code class="sig-name descname">function_longitudinal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.Resonator.function_longitudinal" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the wake function (longitudinal) of a resonator with
the given parameters according to Alex Chao’s resonator model
(Eq. 2.82) and definitions of the resonator in HEADTAIL.</p>
</dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wakes.Resonator.function_transverse">
<code class="sig-name descname">function_transverse</code><span class="sig-paren">(</span><em class="sig-param">Yokoya_factor</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.Resonator.function_transverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the wake function (transverse) of a resonator with
the given parameters according to Alex Chao’s resonator model
(Eq. 2.82) and definitions of the resonator in HEADTAIL.</p>
</dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wakes.Resonator.get_wake_kicks">
<code class="sig-name descname">get_wake_kicks</code><span class="sig-paren">(</span><em class="sig-param">slicer</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.Resonator.get_wake_kicks" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory method. Creates instances of the appropriate
WakeKick objects for a Resonator WakeSource with the specified
parameters. A WakeKick object is instantiated only if the
corresponding Yokoya factor is non-zero. The WakeKick objects
are returned as a list wake_kicks.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.impedances.wakes.WakeField">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wakes.</code><code class="sig-name descname">WakeField</code><span class="sig-paren">(</span><em class="sig-param">slicer</em>, <em class="sig-param">*wake_sources</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.WakeField" title="Permalink to this definition">¶</a></dt>
<dd><p>A WakeField is defined by elementary WakeKick objects that may
originate from different WakeSource objects. Usually, there is
no need for the user to define more than one instance of the
WakeField class in a simulation - except if one wants to use
different slicing configurations (one WakeField object is allowed
to have exactly one slicing configuration, i.e. only one instance
of the Slicer class). A WakeField also is able to calculate the wake
forces coming from earlier turns (multiturn wakes) by archiving the
longitudinal bunch distribution (SliceSet instances) a number of
turns back.</p>
<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.WakeField.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.WakeField.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wakes.WakeField.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">slicer</em>, <em class="sig-param">*wake_sources</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.WakeField.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Accepts a list of WakeSource objects. Each WakeSource object
knows how to generate its corresponding WakeKick objects. The
collection of all the WakeKick objects of each of the passed
WakeSource objects defines the WakeField.
When instantiating the WakeField object, the WakeKick objects
for each WakeSource defined in wake_sources are requested. The
returned WakeKick lists are all stored in the
WakeField.wake_kicks list. The WakeField itself forgets about
the origin (WakeSource) of the kicks as soon as they have been
generated.
Exactly one instance of the Slicer class must be passed to the
WakeField constructor. All the wake field components (kicks)
hence use the same slicing and thus the same slice_set to
calculate the strength of the kicks.
To calculate the contributions from multiturn wakes, the
longitudinal beam distributions (SliceSet instances) are
archived in a deque. In parallel to the slice_set_deque,
there is a slice_set_age_deque to keep track of the age of
each of the SliceSet instances.</p>
</dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.WakeField.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wakes'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.WakeField.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.WakeField._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.WakeField._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wakes.WakeField.track">
<code class="sig-name descname">track</code><span class="sig-paren">(</span><em class="sig-param">bunch</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.WakeField.track" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the WakeKick.apply(bunch, slice_set) method of each of
the WakeKick objects stored in self.wake_kicks. A slice_set is
necessary to perform this operation. It is requested from the
bunch (instance of the Particles class) using the
Particles.get_slices(self.slicer) method, where self.slicer is
the instance of the Slicer class used for this particluar
WakeField object. A slice_set is returned according to the
self.slicer configuration. The statistics mean_x and mean_y are
requested to be calculated and saved in the SliceSet instance,
too, s.t. the first moments x, y can be calculated by the
WakeKick instances.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.impedances.wakes.WakeSource">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wakes.</code><code class="sig-name descname">WakeSource</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.WakeSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for wake sources, such as WakeTable,
Resonator or ResistiveWall.</p>
<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.WakeSource.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({'get_wake_kicks'})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.WakeSource.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.WakeSource.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wakes'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.WakeSource.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.WakeSource._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.WakeSource._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wakes.WakeSource.get_wake_kicks">
<em class="property">abstract </em><code class="sig-name descname">get_wake_kicks</code><span class="sig-paren">(</span><em class="sig-param">slicer_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.WakeSource.get_wake_kicks" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory method. Creates instances of the WakeKick objects
for the given WakeSource and returns them as a list wake_kicks.
This method is usually only called by a WakeField object to
collect and create all the WakeKick objects originating from the
different sources. (The slicer mode Slicer.mode must be passed
at instantiation of a WakeKick object only to set the
appropriate convolution method. See docstrings of WakeKick
class.)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyHEADTAIL.impedances.wakes.WakeTable">
<em class="property">class </em><code class="sig-prename descclassname">PyHEADTAIL.impedances.wakes.</code><code class="sig-name descname">WakeTable</code><span class="sig-paren">(</span><em class="sig-param">wake_file</em>, <em class="sig-param">wake_file_columns</em>, <em class="sig-param">n_turns_wake=1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.WakeTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to define wake functions and WakeKick objects using wake
data from a table.</p>
<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.WakeTable.__abstractmethods__">
<code class="sig-name descname">__abstractmethods__</code><em class="property"> = frozenset({})</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.WakeTable.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wakes.WakeTable.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">wake_file</em>, <em class="sig-param">wake_file_columns</em>, <em class="sig-param">n_turns_wake=1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.WakeTable.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Load data from the wake_file and store them in a dictionary
self.wake_table. Keys are the names specified by the user in
wake_file_columns and describe the names of the wake field
components (e.g. dipole_x or dipole_yx). The dict values are
given by the corresponding data read from the table. The
nomenclature of the wake components must be strictly obeyed.
Valid names for wake components are:</p>
<p>‘constant_x’, ‘constant_y’, ‘dipole_x’, ‘dipole_y’, ‘dipole_xy’,
‘dipole_yx’, ‘quadrupole_x’, ‘quadrupole_y’, ‘quadrupole_xy’,
‘quadrupole_yx’, ‘longitudinal’.</p>
<p>The order of wake_file_columns is relevant and must correspond
to the one in the wake_file. There is no way to check this here
and it is in the responsibility of the user to ensure it is
correct. Two checks made here are whether the length of
wake_file_columns corresponds to the number of columns in the
wake_file and whether a column ‘time’ is specified.</p>
<p>The units and signs of the wake table data are assumed to follow
the HEADTAIL conventions, i.e.</p>
<blockquote>
<div><p>time: [ns]
transverse wake components: [V/pC/mm]
longitudinal wake component: [V/pC].</p>
</div></blockquote>
<p>The parameter ‘n_turns_wake’ defines how many turns are
considered for the multiturn wakes. It is 1 by default, i.e.
multiturn wakes are off.</p>
</dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.WakeTable.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'PyHEADTAIL.impedances.wakes'</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.WakeTable.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="PyHEADTAIL.impedances.wakes.WakeTable._abc_impl">
<code class="sig-name descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.WakeTable._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wakes.WakeTable._is_provided">
<code class="sig-name descname">_is_provided</code><span class="sig-paren">(</span><em class="sig-param">wake_component</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.WakeTable._is_provided" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether wake_component is a valid name and available
in wake table data. Return ‘True’ if yes and ‘False’ if no.</p>
</dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wakes.WakeTable.function_longitudinal">
<code class="sig-name descname">function_longitudinal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.WakeTable.function_longitudinal" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines and returns the wake(dt) function for the given
wake_component (longitudinal). Data from the wake table are
used, but first converted to SI units assuming that time is
specified in [ns] and longitudinal wake field strength in
[V/pC]. Sign conventions are applied (HEADTAIL conventions).
The wake(dt) uses the scipy.interpolate.interp1d linear
interpolation to calculate the wake strength at an arbitrary
value of dt (provided it is in the valid range). The valid range
of dt is given by the time range from the wake table. If values
of wake(dt) are requested for dt outside the valid range, a
ValueError is raised by interp1d.
The beam loading theorem is respected and applied for dt=0.</p>
</dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wakes.WakeTable.function_transverse">
<code class="sig-name descname">function_transverse</code><span class="sig-paren">(</span><em class="sig-param">wake_component</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.WakeTable.function_transverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines and returns the wake(beta, dz) function for the
given wake_component (transverse). Data from the wake table are
used, but first converted to SI units assuming that time is
specified in [ns] and transverse wake field strengths in
[V/pC/mm]. Sign conventions are applied (HEADTAIL conventions).
dz is related to wake table time data by dz = beta c dt (dz &lt; 0
for the ultrarelativistic case).
The wake(dt) uses the scipy.interpolate.interp1d linear
interpolation to calculate the wake strength at an arbitrary
value of dt (provided it is in the valid range). The valid range
of dt is given by the time range from the wake table. If values
of wake(dt) are requested for dt outside the valid range, a
ValueError is raised by interp1d.
Very basic conformity checks for the wake table data are already
performed at definition time of the wake(dt) method. E.g.
whether the specified wake is valid only for ultrarelativistic
cases or low beta cases. In the former case, the wake strength
at time 0 must be defined by the user!</p>
</dd></dl>

<dl class="method">
<dt id="PyHEADTAIL.impedances.wakes.WakeTable.get_wake_kicks">
<code class="sig-name descname">get_wake_kicks</code><span class="sig-paren">(</span><em class="sig-param">slicer</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.WakeTable.get_wake_kicks" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory method. Creates instances of the appropriate
WakeKick objects for all the wake components provided by the
user (and the wake table data). The WakeKick objects are
returned as a list wake_kicks.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="PyHEADTAIL.impedances.wakes.check_wake_sampling">
<code class="sig-prename descclassname">PyHEADTAIL.impedances.wakes.</code><code class="sig-name descname">check_wake_sampling</code><span class="sig-paren">(</span><em class="sig-param">bunch</em>, <em class="sig-param">slicer</em>, <em class="sig-param">wakes</em>, <em class="sig-param">beta=1</em>, <em class="sig-param">wake_column=None</em>, <em class="sig-param">bins=False</em><span class="sig-paren">)</span><a class="headerlink" href="#PyHEADTAIL.impedances.wakes.check_wake_sampling" title="Permalink to this definition">¶</a></dt>
<dd><p>Handy function for quick visual check of sampling of the wake functions.
For now only implemented for wake table type wakes.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">PyHEADTAIL.impedances package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-PyHEADTAIL.impedances.wake_kicks">PyHEADTAIL.impedances.wake_kicks module</a></li>
<li><a class="reference internal" href="#module-PyHEADTAIL.impedances.wakes">PyHEADTAIL.impedances.wakes module</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="PyHEADTAIL.gpu.html"
                        title="previous chapter">PyHEADTAIL.gpu package</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="PyHEADTAIL.machines.html"
                        title="next chapter">PyHEADTAIL.machines package</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/PyHEADTAIL.impedances.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="PyHEADTAIL.machines.html" title="PyHEADTAIL.machines package"
             >next</a> |</li>
        <li class="right" >
          <a href="PyHEADTAIL.gpu.html" title="PyHEADTAIL.gpu package"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PyHEADTAIL  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="PyHEADTAIL.html" >PyHEADTAIL package</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Author.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.2.
    </div>
  </body>
</html>